package com.kymatic.tenantservice.config;

import com.kymatic.tenantservice.util.JwtTokenUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.core.OAuth2Error;
import org.springframework.security.oauth2.core.OAuth2ErrorCodes;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;

import java.util.HashMap;
import java.util.Map;

/**
 * Composite JWT decoder that handles both Keycloak tokens (RS256 from JWKS) 
 * and local authentication tokens (HS256 with shared secret).
 * 
 * This decoder:
 * 1. Attempts to decode as Keycloak token first (RS256 from JWKS)
 * 2. Falls back to local token decoder (HS256 with shared secret) if Keycloak decoding fails
 * 
 * This allows the system to support both Keycloak authentication and local authentication.
 */
public class CompositeJwtDecoder implements JwtDecoder {

    private static final Logger logger = LoggerFactory.getLogger(CompositeJwtDecoder.class);

    private final JwtDecoder keycloakDecoder;
    private final LocalJwtDecoder localDecoder;

    public CompositeJwtDecoder(JwtDecoder keycloakDecoder, JwtTokenUtil jwtTokenUtil, String localIssuer) {
        this.keycloakDecoder = keycloakDecoder;
        this.localDecoder = new LocalJwtDecoder(jwtTokenUtil, localIssuer);
    }

    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            // Try Keycloak decoder first (RS256 from JWKS)
            return keycloakDecoder.decode(token);
        } catch (JwtException keycloakException) {
            // If Keycloak decoding fails, try local decoder
            logger.debug("Keycloak token decoding failed, trying local decoder: {}", keycloakException.getMessage());
            try {
                return localDecoder.decode(token);
            } catch (JwtException localException) {
                // Both decoders failed - log and throw the original Keycloak exception
                logger.error("Both Keycloak and local token decoding failed. Keycloak error: {}, Local error: {}", 
                    keycloakException.getMessage(), localException.getMessage());
                throw keycloakException; // Throw original exception
            }
        }
    }

    /**
     * Local JWT decoder for tokens generated by JwtTokenUtil (HS256 with shared secret)
     */
    private static class LocalJwtDecoder implements JwtDecoder {
        
        private final JwtTokenUtil jwtTokenUtil;
        private final String expectedIssuer;

        public LocalJwtDecoder(JwtTokenUtil jwtTokenUtil, String expectedIssuer) {
            this.jwtTokenUtil = jwtTokenUtil;
            this.expectedIssuer = expectedIssuer;
        }

        @Override
        public Jwt decode(String token) throws JwtException {
            try {
                // Parse and validate token using JwtTokenUtil
                var claims = jwtTokenUtil.parseToken(token);
                
                // Extract claims (Claims is from io.jsonwebtoken.Claims)
                String sub = claims.getSubject();
                String issuer = claims.getIssuer();
                String email = claims.get("email", String.class);
                String preferredUsername = claims.get("preferred_username", String.class);
                if (preferredUsername == null) preferredUsername = email;
                String tenantId = claims.get("tenant_id", String.class);
                String role = claims.get("role", String.class);
                
                java.util.Date issuedAtDate = claims.getIssuedAt();
                java.util.Date expiresAtDate = claims.getExpiration();
                
                if (issuedAtDate == null) {
                    issuedAtDate = new java.util.Date();
                }
                if (expiresAtDate == null) {
                    expiresAtDate = new java.util.Date(issuedAtDate.getTime() + 3600 * 1000);
                }
                
                java.time.Instant issuedAt = issuedAtDate.toInstant();
                java.time.Instant expiresAt = expiresAtDate.toInstant();
                
                // Verify issuer matches expected local issuer
                if (issuer == null || !issuer.startsWith(expectedIssuer)) {
                    throw new OAuth2AuthenticationException(
                        new OAuth2Error(
                            OAuth2ErrorCodes.INVALID_TOKEN,
                            "Token issuer does not match local issuer. Expected: " + expectedIssuer + ", Got: " + issuer,
                            null
                        )
                    );
                }

                // Build Spring Security Jwt object with all claims
                Map<String, Object> headers = Map.of(
                    "alg", "HS256",
                    "typ", "JWT"
                );

                Map<String, Object> jwtClaims = new java.util.HashMap<>();
                jwtClaims.put("sub", sub);
                if (email != null) jwtClaims.put("email", email);
                if (preferredUsername != null) jwtClaims.put("preferred_username", preferredUsername);
                if (tenantId != null) jwtClaims.put("tenant_id", tenantId);
                if (role != null) jwtClaims.put("role", role);
                jwtClaims.put("iss", issuer);
                jwtClaims.put("iat", issuedAt.getEpochSecond());
                jwtClaims.put("exp", expiresAt.getEpochSecond());

                return Jwt.withTokenValue(token)
                        .headers(h -> h.putAll(headers))
                        .claims(c -> c.putAll(jwtClaims))
                        .issuedAt(issuedAt)
                        .expiresAt(expiresAt)
                        .issuer(issuer)
                        .build();

            } catch (OAuth2AuthenticationException e) {
                // Re-throw OAuth2 exceptions as-is
                throw e;
            } catch (Exception e) {
                logger.error("Failed to decode local JWT token", e);
                throw new OAuth2AuthenticationException(
                    new OAuth2Error(
                        OAuth2ErrorCodes.INVALID_TOKEN,
                        "Failed to decode local JWT token: " + e.getMessage(),
                        null
                    ),
                    e
                );
            }
        }
    }
}

